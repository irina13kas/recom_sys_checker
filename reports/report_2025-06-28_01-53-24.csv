message
🧪 Функциональные тесты
------------------------------
❌ Некоторые функциональные тесты не пройдены:
""
============================= test session starts =============================
"platform win32 -- Python 3.13.5, pytest-8.4.1, pluggy-1.6.0"
rootdir: C:\Users\mira1\OneDrive\Документы\Политех\3 курс\6 семестр\Практика\recom_sys_checker
collected 11 items
""
logic\tests\collaborative_tests.py .FFFFFFFFFF
""
================================== FAILURES ===================================
_________________________ test_has_required_functions _________________________
""
    def test_has_required_functions():
>       solution = load_solution_module()
                   ^^^^^^^^^^^^^^^^^^^^^^
""
logic\tests\collaborative_tests.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
logic\tests\collaborative_tests.py:29: in load_solution_module
    spec.loader.exec_module(module)
<frozen importlib._bootstrap_external>:1026: in exec_module
    ???
<frozen importlib._bootstrap>:488: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
""
    import pandas as pd
    import numpy as np
    from scipy.sparse import csr_matrix
    from sklearn.metrics.pairwise import cosine_similarity
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import mean_squared_error
    from math import sqrt
    from typing import List
    
    
    item_similarity = None
    user_item_matrix = None
    items = None
    users = None
    
"    def fit(self, train_data: pd.DataFrame) -> None:"
"        """"""Обучает модель на тренировочном датасете."""""""
        # Создаем user-item матрицу
        self.users = train_data['user_id'].unique()
        self.items = train_data['item'].unique()
    
        # Создаем разреженную матрицу пользователь-фильм
"        user_to_idx = {user: idx for idx, user in enumerate(self.users)}"
"        item_to_idx = {item: idx for idx, item in enumerate(self.items)}"
    
        rows = train_data['user_id'].map(user_to_idx)
        cols = train_data['item'].map(item_to_idx)
        ratings = train_data['rating']
    
"        self.user_item_matrix = csr_matrix((ratings, (rows, cols)),"
"                                            shape=(len(self.users), len(self.items)))"
    
        # Вычисляем косинусную схожесть между фильмами (аналог Pearson)
        self.item_similarity = cosine_similarity(self.user_item_matrix.T)
    
"    def recommend(self, user_id: int, k: int) -> List[int]:"
"        """"""Возвращает список из k item_id, рекомендованных пользователю."""""""
        if user_id not in self.users:
            return []
    
        user_idx = np.where(self.users == user_id)[0][0]
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
    
"        # Индексы фильмов, которые пользователь еще не оценил"
        unrated_items = np.where(user_ratings == 0)[0]
    
        if len(unrated_items) == 0:
            return []
    
        # Предсказываем рейтинги для неоцененных фильмов
        pred_ratings = []
        for item_idx in unrated_items:
"            # Находим индексы фильмов, которые пользователь оценил"
            rated_items = np.where(user_ratings > 0)[0]
    
            # Берем top-5 наиболее похожих фильмов из оцененных пользователем
"            sim_scores = self.item_similarity[item_idx, rated_items]"
            top_k_indices = np.argsort(sim_scores)[-5:]
            top_k_sim = sim_scores[top_k_indices]
            top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
            # Взвешенное среднее с учетом схожести
            if top_k_sim.sum() > 0:
"                pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
            else:
                pred_rating = 0
    
"            pred_ratings.append((self.items[item_idx], pred_rating))"
    
        # Сортируем по предсказанному рейтингу и возвращаем top-k
"        pred_ratings.sort(key=lambda x: x[1], reverse=True)"
"        return [item for item, _ in pred_ratings[:k]]"
    
"    def predict(self, user_id: int, item_id: int) -> float:"
"        """"""Предсказывает рейтинг для пары пользователь-фильм."""""""
        if user_id not in self.users or item_id not in self.items:
            return 0.0
    
        user_idx = np.where(self.users == user_id)[0][0]
        item_idx = np.where(self.items == item_id)[0][0]
    
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
        rated_items = np.where(user_ratings > 0)[0]
    
        if len(rated_items) == 0:
            return 0.0
    
        # Берем top-5 наиболее похожих фильмов из оцененных пользователем
"        sim_scores = self.item_similarity[item_idx, rated_items]"
        top_k_indices = np.argsort(sim_scores)[-5:]
        top_k_sim = sim_scores[top_k_indices]
        top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
        # Взвешенное среднее с учетом схожести
        if top_k_sim.sum() > 0:
"            pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
        else:
            pred_rating = 0.0
    
        return pred_rating
    
">   def evaluate(test_data: pd.DataFrame, model: ItemBasedCF) -> float:"
                                                 ^^^^^^^^^^^
E   NameError: name 'ItemBasedCF' is not defined
""
solutions\solution.py:102: NameError
_________________________ test_fit_runs_without_error _________________________
""
    def test_fit_runs_without_error():
        sample_data = get_dummy_data()
>       solution = load_solution_module()
                   ^^^^^^^^^^^^^^^^^^^^^^
""
logic\tests\collaborative_tests.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
logic\tests\collaborative_tests.py:29: in load_solution_module
    spec.loader.exec_module(module)
<frozen importlib._bootstrap_external>:1026: in exec_module
    ???
<frozen importlib._bootstrap>:488: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
""
    import pandas as pd
    import numpy as np
    from scipy.sparse import csr_matrix
    from sklearn.metrics.pairwise import cosine_similarity
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import mean_squared_error
    from math import sqrt
    from typing import List
    
    
    item_similarity = None
    user_item_matrix = None
    items = None
    users = None
    
"    def fit(self, train_data: pd.DataFrame) -> None:"
"        """"""Обучает модель на тренировочном датасете."""""""
        # Создаем user-item матрицу
        self.users = train_data['user_id'].unique()
        self.items = train_data['item'].unique()
    
        # Создаем разреженную матрицу пользователь-фильм
"        user_to_idx = {user: idx for idx, user in enumerate(self.users)}"
"        item_to_idx = {item: idx for idx, item in enumerate(self.items)}"
    
        rows = train_data['user_id'].map(user_to_idx)
        cols = train_data['item'].map(item_to_idx)
        ratings = train_data['rating']
    
"        self.user_item_matrix = csr_matrix((ratings, (rows, cols)),"
"                                            shape=(len(self.users), len(self.items)))"
    
        # Вычисляем косинусную схожесть между фильмами (аналог Pearson)
        self.item_similarity = cosine_similarity(self.user_item_matrix.T)
    
"    def recommend(self, user_id: int, k: int) -> List[int]:"
"        """"""Возвращает список из k item_id, рекомендованных пользователю."""""""
        if user_id not in self.users:
            return []
    
        user_idx = np.where(self.users == user_id)[0][0]
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
    
"        # Индексы фильмов, которые пользователь еще не оценил"
        unrated_items = np.where(user_ratings == 0)[0]
    
        if len(unrated_items) == 0:
            return []
    
        # Предсказываем рейтинги для неоцененных фильмов
        pred_ratings = []
        for item_idx in unrated_items:
"            # Находим индексы фильмов, которые пользователь оценил"
            rated_items = np.where(user_ratings > 0)[0]
    
            # Берем top-5 наиболее похожих фильмов из оцененных пользователем
"            sim_scores = self.item_similarity[item_idx, rated_items]"
            top_k_indices = np.argsort(sim_scores)[-5:]
            top_k_sim = sim_scores[top_k_indices]
            top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
            # Взвешенное среднее с учетом схожести
            if top_k_sim.sum() > 0:
"                pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
            else:
                pred_rating = 0
    
"            pred_ratings.append((self.items[item_idx], pred_rating))"
    
        # Сортируем по предсказанному рейтингу и возвращаем top-k
"        pred_ratings.sort(key=lambda x: x[1], reverse=True)"
"        return [item for item, _ in pred_ratings[:k]]"
    
"    def predict(self, user_id: int, item_id: int) -> float:"
"        """"""Предсказывает рейтинг для пары пользователь-фильм."""""""
        if user_id not in self.users or item_id not in self.items:
            return 0.0
    
        user_idx = np.where(self.users == user_id)[0][0]
        item_idx = np.where(self.items == item_id)[0][0]
    
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
        rated_items = np.where(user_ratings > 0)[0]
    
        if len(rated_items) == 0:
            return 0.0
    
        # Берем top-5 наиболее похожих фильмов из оцененных пользователем
"        sim_scores = self.item_similarity[item_idx, rated_items]"
        top_k_indices = np.argsort(sim_scores)[-5:]
        top_k_sim = sim_scores[top_k_indices]
        top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
        # Взвешенное среднее с учетом схожести
        if top_k_sim.sum() > 0:
"            pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
        else:
            pred_rating = 0.0
    
        return pred_rating
    
">   def evaluate(test_data: pd.DataFrame, model: ItemBasedCF) -> float:"
                                                 ^^^^^^^^^^^
E   NameError: name 'ItemBasedCF' is not defined
""
solutions\solution.py:102: NameError
___________________ test_fit_and_recommend_on_generated[1] ____________________
""
"task_info = None, k = 1"
""
"    @pytest.mark.parametrize(""k"", [1, 2, 3])"
"    def test_fit_and_recommend_on_generated(task_info, k):"
>       solution = load_solution_module()
                   ^^^^^^^^^^^^^^^^^^^^^^
""
logic\tests\collaborative_tests.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
logic\tests\collaborative_tests.py:29: in load_solution_module
    spec.loader.exec_module(module)
<frozen importlib._bootstrap_external>:1026: in exec_module
    ???
<frozen importlib._bootstrap>:488: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
""
    import pandas as pd
    import numpy as np
    from scipy.sparse import csr_matrix
    from sklearn.metrics.pairwise import cosine_similarity
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import mean_squared_error
    from math import sqrt
    from typing import List
    
    
    item_similarity = None
    user_item_matrix = None
    items = None
    users = None
    
"    def fit(self, train_data: pd.DataFrame) -> None:"
"        """"""Обучает модель на тренировочном датасете."""""""
        # Создаем user-item матрицу
        self.users = train_data['user_id'].unique()
        self.items = train_data['item'].unique()
    
        # Создаем разреженную матрицу пользователь-фильм
"        user_to_idx = {user: idx for idx, user in enumerate(self.users)}"
"        item_to_idx = {item: idx for idx, item in enumerate(self.items)}"
    
        rows = train_data['user_id'].map(user_to_idx)
        cols = train_data['item'].map(item_to_idx)
        ratings = train_data['rating']
    
"        self.user_item_matrix = csr_matrix((ratings, (rows, cols)),"
"                                            shape=(len(self.users), len(self.items)))"
    
        # Вычисляем косинусную схожесть между фильмами (аналог Pearson)
        self.item_similarity = cosine_similarity(self.user_item_matrix.T)
    
"    def recommend(self, user_id: int, k: int) -> List[int]:"
"        """"""Возвращает список из k item_id, рекомендованных пользователю."""""""
        if user_id not in self.users:
            return []
    
        user_idx = np.where(self.users == user_id)[0][0]
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
    
"        # Индексы фильмов, которые пользователь еще не оценил"
        unrated_items = np.where(user_ratings == 0)[0]
    
        if len(unrated_items) == 0:
            return []
    
        # Предсказываем рейтинги для неоцененных фильмов
        pred_ratings = []
        for item_idx in unrated_items:
"            # Находим индексы фильмов, которые пользователь оценил"
            rated_items = np.where(user_ratings > 0)[0]
    
            # Берем top-5 наиболее похожих фильмов из оцененных пользователем
"            sim_scores = self.item_similarity[item_idx, rated_items]"
            top_k_indices = np.argsort(sim_scores)[-5:]
            top_k_sim = sim_scores[top_k_indices]
            top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
            # Взвешенное среднее с учетом схожести
            if top_k_sim.sum() > 0:
"                pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
            else:
                pred_rating = 0
    
"            pred_ratings.append((self.items[item_idx], pred_rating))"
    
        # Сортируем по предсказанному рейтингу и возвращаем top-k
"        pred_ratings.sort(key=lambda x: x[1], reverse=True)"
"        return [item for item, _ in pred_ratings[:k]]"
    
"    def predict(self, user_id: int, item_id: int) -> float:"
"        """"""Предсказывает рейтинг для пары пользователь-фильм."""""""
        if user_id not in self.users or item_id not in self.items:
            return 0.0
    
        user_idx = np.where(self.users == user_id)[0][0]
        item_idx = np.where(self.items == item_id)[0][0]
    
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
        rated_items = np.where(user_ratings > 0)[0]
    
        if len(rated_items) == 0:
            return 0.0
    
        # Берем top-5 наиболее похожих фильмов из оцененных пользователем
"        sim_scores = self.item_similarity[item_idx, rated_items]"
        top_k_indices = np.argsort(sim_scores)[-5:]
        top_k_sim = sim_scores[top_k_indices]
        top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
        # Взвешенное среднее с учетом схожести
        if top_k_sim.sum() > 0:
"            pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
        else:
            pred_rating = 0.0
    
        return pred_rating
    
">   def evaluate(test_data: pd.DataFrame, model: ItemBasedCF) -> float:"
                                                 ^^^^^^^^^^^
E   NameError: name 'ItemBasedCF' is not defined
""
solutions\solution.py:102: NameError
___________________ test_fit_and_recommend_on_generated[2] ____________________
""
"task_info = None, k = 2"
""
"    @pytest.mark.parametrize(""k"", [1, 2, 3])"
"    def test_fit_and_recommend_on_generated(task_info, k):"
>       solution = load_solution_module()
                   ^^^^^^^^^^^^^^^^^^^^^^
""
logic\tests\collaborative_tests.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
logic\tests\collaborative_tests.py:29: in load_solution_module
    spec.loader.exec_module(module)
<frozen importlib._bootstrap_external>:1026: in exec_module
    ???
<frozen importlib._bootstrap>:488: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
""
    import pandas as pd
    import numpy as np
    from scipy.sparse import csr_matrix
    from sklearn.metrics.pairwise import cosine_similarity
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import mean_squared_error
    from math import sqrt
    from typing import List
    
    
    item_similarity = None
    user_item_matrix = None
    items = None
    users = None
    
"    def fit(self, train_data: pd.DataFrame) -> None:"
"        """"""Обучает модель на тренировочном датасете."""""""
        # Создаем user-item матрицу
        self.users = train_data['user_id'].unique()
        self.items = train_data['item'].unique()
    
        # Создаем разреженную матрицу пользователь-фильм
"        user_to_idx = {user: idx for idx, user in enumerate(self.users)}"
"        item_to_idx = {item: idx for idx, item in enumerate(self.items)}"
    
        rows = train_data['user_id'].map(user_to_idx)
        cols = train_data['item'].map(item_to_idx)
        ratings = train_data['rating']
    
"        self.user_item_matrix = csr_matrix((ratings, (rows, cols)),"
"                                            shape=(len(self.users), len(self.items)))"
    
        # Вычисляем косинусную схожесть между фильмами (аналог Pearson)
        self.item_similarity = cosine_similarity(self.user_item_matrix.T)
    
"    def recommend(self, user_id: int, k: int) -> List[int]:"
"        """"""Возвращает список из k item_id, рекомендованных пользователю."""""""
        if user_id not in self.users:
            return []
    
        user_idx = np.where(self.users == user_id)[0][0]
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
    
"        # Индексы фильмов, которые пользователь еще не оценил"
        unrated_items = np.where(user_ratings == 0)[0]
    
        if len(unrated_items) == 0:
            return []
    
        # Предсказываем рейтинги для неоцененных фильмов
        pred_ratings = []
        for item_idx in unrated_items:
"            # Находим индексы фильмов, которые пользователь оценил"
            rated_items = np.where(user_ratings > 0)[0]
    
            # Берем top-5 наиболее похожих фильмов из оцененных пользователем
"            sim_scores = self.item_similarity[item_idx, rated_items]"
            top_k_indices = np.argsort(sim_scores)[-5:]
            top_k_sim = sim_scores[top_k_indices]
            top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
            # Взвешенное среднее с учетом схожести
            if top_k_sim.sum() > 0:
"                pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
            else:
                pred_rating = 0
    
"            pred_ratings.append((self.items[item_idx], pred_rating))"
    
        # Сортируем по предсказанному рейтингу и возвращаем top-k
"        pred_ratings.sort(key=lambda x: x[1], reverse=True)"
"        return [item for item, _ in pred_ratings[:k]]"
    
"    def predict(self, user_id: int, item_id: int) -> float:"
"        """"""Предсказывает рейтинг для пары пользователь-фильм."""""""
        if user_id not in self.users or item_id not in self.items:
            return 0.0
    
        user_idx = np.where(self.users == user_id)[0][0]
        item_idx = np.where(self.items == item_id)[0][0]
    
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
        rated_items = np.where(user_ratings > 0)[0]
    
        if len(rated_items) == 0:
            return 0.0
    
        # Берем top-5 наиболее похожих фильмов из оцененных пользователем
"        sim_scores = self.item_similarity[item_idx, rated_items]"
        top_k_indices = np.argsort(sim_scores)[-5:]
        top_k_sim = sim_scores[top_k_indices]
        top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
        # Взвешенное среднее с учетом схожести
        if top_k_sim.sum() > 0:
"            pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
        else:
            pred_rating = 0.0
    
        return pred_rating
    
">   def evaluate(test_data: pd.DataFrame, model: ItemBasedCF) -> float:"
                                                 ^^^^^^^^^^^
E   NameError: name 'ItemBasedCF' is not defined
""
solutions\solution.py:102: NameError
___________________ test_fit_and_recommend_on_generated[3] ____________________
""
"task_info = None, k = 3"
""
"    @pytest.mark.parametrize(""k"", [1, 2, 3])"
"    def test_fit_and_recommend_on_generated(task_info, k):"
>       solution = load_solution_module()
                   ^^^^^^^^^^^^^^^^^^^^^^
""
logic\tests\collaborative_tests.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
logic\tests\collaborative_tests.py:29: in load_solution_module
    spec.loader.exec_module(module)
<frozen importlib._bootstrap_external>:1026: in exec_module
    ???
<frozen importlib._bootstrap>:488: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
""
    import pandas as pd
    import numpy as np
    from scipy.sparse import csr_matrix
    from sklearn.metrics.pairwise import cosine_similarity
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import mean_squared_error
    from math import sqrt
    from typing import List
    
    
    item_similarity = None
    user_item_matrix = None
    items = None
    users = None
    
"    def fit(self, train_data: pd.DataFrame) -> None:"
"        """"""Обучает модель на тренировочном датасете."""""""
        # Создаем user-item матрицу
        self.users = train_data['user_id'].unique()
        self.items = train_data['item'].unique()
    
        # Создаем разреженную матрицу пользователь-фильм
"        user_to_idx = {user: idx for idx, user in enumerate(self.users)}"
"        item_to_idx = {item: idx for idx, item in enumerate(self.items)}"
    
        rows = train_data['user_id'].map(user_to_idx)
        cols = train_data['item'].map(item_to_idx)
        ratings = train_data['rating']
    
"        self.user_item_matrix = csr_matrix((ratings, (rows, cols)),"
"                                            shape=(len(self.users), len(self.items)))"
    
        # Вычисляем косинусную схожесть между фильмами (аналог Pearson)
        self.item_similarity = cosine_similarity(self.user_item_matrix.T)
    
"    def recommend(self, user_id: int, k: int) -> List[int]:"
"        """"""Возвращает список из k item_id, рекомендованных пользователю."""""""
        if user_id not in self.users:
            return []
    
        user_idx = np.where(self.users == user_id)[0][0]
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
    
"        # Индексы фильмов, которые пользователь еще не оценил"
        unrated_items = np.where(user_ratings == 0)[0]
    
        if len(unrated_items) == 0:
            return []
    
        # Предсказываем рейтинги для неоцененных фильмов
        pred_ratings = []
        for item_idx in unrated_items:
"            # Находим индексы фильмов, которые пользователь оценил"
            rated_items = np.where(user_ratings > 0)[0]
    
            # Берем top-5 наиболее похожих фильмов из оцененных пользователем
"            sim_scores = self.item_similarity[item_idx, rated_items]"
            top_k_indices = np.argsort(sim_scores)[-5:]
            top_k_sim = sim_scores[top_k_indices]
            top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
            # Взвешенное среднее с учетом схожести
            if top_k_sim.sum() > 0:
"                pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
            else:
                pred_rating = 0
    
"            pred_ratings.append((self.items[item_idx], pred_rating))"
    
        # Сортируем по предсказанному рейтингу и возвращаем top-k
"        pred_ratings.sort(key=lambda x: x[1], reverse=True)"
"        return [item for item, _ in pred_ratings[:k]]"
    
"    def predict(self, user_id: int, item_id: int) -> float:"
"        """"""Предсказывает рейтинг для пары пользователь-фильм."""""""
        if user_id not in self.users or item_id not in self.items:
            return 0.0
    
        user_idx = np.where(self.users == user_id)[0][0]
        item_idx = np.where(self.items == item_id)[0][0]
    
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
        rated_items = np.where(user_ratings > 0)[0]
    
        if len(rated_items) == 0:
            return 0.0
    
        # Берем top-5 наиболее похожих фильмов из оцененных пользователем
"        sim_scores = self.item_similarity[item_idx, rated_items]"
        top_k_indices = np.argsort(sim_scores)[-5:]
        top_k_sim = sim_scores[top_k_indices]
        top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
        # Взвешенное среднее с учетом схожести
        if top_k_sim.sum() > 0:
"            pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
        else:
            pred_rating = 0.0
    
        return pred_rating
    
">   def evaluate(test_data: pd.DataFrame, model: ItemBasedCF) -> float:"
                                                 ^^^^^^^^^^^
E   NameError: name 'ItemBasedCF' is not defined
""
solutions\solution.py:102: NameError
________________________ test_recommend_items_not_seen ________________________
""
task_info = None
""
    def test_recommend_items_not_seen(task_info):
>       solution = load_solution_module()
                   ^^^^^^^^^^^^^^^^^^^^^^
""
logic\tests\collaborative_tests.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
logic\tests\collaborative_tests.py:29: in load_solution_module
    spec.loader.exec_module(module)
<frozen importlib._bootstrap_external>:1026: in exec_module
    ???
<frozen importlib._bootstrap>:488: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
""
    import pandas as pd
    import numpy as np
    from scipy.sparse import csr_matrix
    from sklearn.metrics.pairwise import cosine_similarity
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import mean_squared_error
    from math import sqrt
    from typing import List
    
    
    item_similarity = None
    user_item_matrix = None
    items = None
    users = None
    
"    def fit(self, train_data: pd.DataFrame) -> None:"
"        """"""Обучает модель на тренировочном датасете."""""""
        # Создаем user-item матрицу
        self.users = train_data['user_id'].unique()
        self.items = train_data['item'].unique()
    
        # Создаем разреженную матрицу пользователь-фильм
"        user_to_idx = {user: idx for idx, user in enumerate(self.users)}"
"        item_to_idx = {item: idx for idx, item in enumerate(self.items)}"
    
        rows = train_data['user_id'].map(user_to_idx)
        cols = train_data['item'].map(item_to_idx)
        ratings = train_data['rating']
    
"        self.user_item_matrix = csr_matrix((ratings, (rows, cols)),"
"                                            shape=(len(self.users), len(self.items)))"
    
        # Вычисляем косинусную схожесть между фильмами (аналог Pearson)
        self.item_similarity = cosine_similarity(self.user_item_matrix.T)
    
"    def recommend(self, user_id: int, k: int) -> List[int]:"
"        """"""Возвращает список из k item_id, рекомендованных пользователю."""""""
        if user_id not in self.users:
            return []
    
        user_idx = np.where(self.users == user_id)[0][0]
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
    
"        # Индексы фильмов, которые пользователь еще не оценил"
        unrated_items = np.where(user_ratings == 0)[0]
    
        if len(unrated_items) == 0:
            return []
    
        # Предсказываем рейтинги для неоцененных фильмов
        pred_ratings = []
        for item_idx in unrated_items:
"            # Находим индексы фильмов, которые пользователь оценил"
            rated_items = np.where(user_ratings > 0)[0]
    
            # Берем top-5 наиболее похожих фильмов из оцененных пользователем
"            sim_scores = self.item_similarity[item_idx, rated_items]"
            top_k_indices = np.argsort(sim_scores)[-5:]
            top_k_sim = sim_scores[top_k_indices]
            top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
            # Взвешенное среднее с учетом схожести
            if top_k_sim.sum() > 0:
"                pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
            else:
                pred_rating = 0
    
"            pred_ratings.append((self.items[item_idx], pred_rating))"
    
        # Сортируем по предсказанному рейтингу и возвращаем top-k
"        pred_ratings.sort(key=lambda x: x[1], reverse=True)"
"        return [item for item, _ in pred_ratings[:k]]"
    
"    def predict(self, user_id: int, item_id: int) -> float:"
"        """"""Предсказывает рейтинг для пары пользователь-фильм."""""""
        if user_id not in self.users or item_id not in self.items:
            return 0.0
    
        user_idx = np.where(self.users == user_id)[0][0]
        item_idx = np.where(self.items == item_id)[0][0]
    
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
        rated_items = np.where(user_ratings > 0)[0]
    
        if len(rated_items) == 0:
            return 0.0
    
        # Берем top-5 наиболее похожих фильмов из оцененных пользователем
"        sim_scores = self.item_similarity[item_idx, rated_items]"
        top_k_indices = np.argsort(sim_scores)[-5:]
        top_k_sim = sim_scores[top_k_indices]
        top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
        # Взвешенное среднее с учетом схожести
        if top_k_sim.sum() > 0:
"            pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
        else:
            pred_rating = 0.0
    
        return pred_rating
    
">   def evaluate(test_data: pd.DataFrame, model: ItemBasedCF) -> float:"
                                                 ^^^^^^^^^^^
E   NameError: name 'ItemBasedCF' is not defined
""
solutions\solution.py:102: NameError
__________________________ test_repeat_fit_stability __________________________
""
task_info = None
""
    def test_repeat_fit_stability(task_info):
>       solution = load_solution_module()
                   ^^^^^^^^^^^^^^^^^^^^^^
""
logic\tests\collaborative_tests.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
logic\tests\collaborative_tests.py:29: in load_solution_module
    spec.loader.exec_module(module)
<frozen importlib._bootstrap_external>:1026: in exec_module
    ???
<frozen importlib._bootstrap>:488: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
""
    import pandas as pd
    import numpy as np
    from scipy.sparse import csr_matrix
    from sklearn.metrics.pairwise import cosine_similarity
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import mean_squared_error
    from math import sqrt
    from typing import List
    
    
    item_similarity = None
    user_item_matrix = None
    items = None
    users = None
    
"    def fit(self, train_data: pd.DataFrame) -> None:"
"        """"""Обучает модель на тренировочном датасете."""""""
        # Создаем user-item матрицу
        self.users = train_data['user_id'].unique()
        self.items = train_data['item'].unique()
    
        # Создаем разреженную матрицу пользователь-фильм
"        user_to_idx = {user: idx for idx, user in enumerate(self.users)}"
"        item_to_idx = {item: idx for idx, item in enumerate(self.items)}"
    
        rows = train_data['user_id'].map(user_to_idx)
        cols = train_data['item'].map(item_to_idx)
        ratings = train_data['rating']
    
"        self.user_item_matrix = csr_matrix((ratings, (rows, cols)),"
"                                            shape=(len(self.users), len(self.items)))"
    
        # Вычисляем косинусную схожесть между фильмами (аналог Pearson)
        self.item_similarity = cosine_similarity(self.user_item_matrix.T)
    
"    def recommend(self, user_id: int, k: int) -> List[int]:"
"        """"""Возвращает список из k item_id, рекомендованных пользователю."""""""
        if user_id not in self.users:
            return []
    
        user_idx = np.where(self.users == user_id)[0][0]
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
    
"        # Индексы фильмов, которые пользователь еще не оценил"
        unrated_items = np.where(user_ratings == 0)[0]
    
        if len(unrated_items) == 0:
            return []
    
        # Предсказываем рейтинги для неоцененных фильмов
        pred_ratings = []
        for item_idx in unrated_items:
"            # Находим индексы фильмов, которые пользователь оценил"
            rated_items = np.where(user_ratings > 0)[0]
    
            # Берем top-5 наиболее похожих фильмов из оцененных пользователем
"            sim_scores = self.item_similarity[item_idx, rated_items]"
            top_k_indices = np.argsort(sim_scores)[-5:]
            top_k_sim = sim_scores[top_k_indices]
            top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
            # Взвешенное среднее с учетом схожести
            if top_k_sim.sum() > 0:
"                pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
            else:
                pred_rating = 0
    
"            pred_ratings.append((self.items[item_idx], pred_rating))"
    
        # Сортируем по предсказанному рейтингу и возвращаем top-k
"        pred_ratings.sort(key=lambda x: x[1], reverse=True)"
"        return [item for item, _ in pred_ratings[:k]]"
    
"    def predict(self, user_id: int, item_id: int) -> float:"
"        """"""Предсказывает рейтинг для пары пользователь-фильм."""""""
        if user_id not in self.users or item_id not in self.items:
            return 0.0
    
        user_idx = np.where(self.users == user_id)[0][0]
        item_idx = np.where(self.items == item_id)[0][0]
    
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
        rated_items = np.where(user_ratings > 0)[0]
    
        if len(rated_items) == 0:
            return 0.0
    
        # Берем top-5 наиболее похожих фильмов из оцененных пользователем
"        sim_scores = self.item_similarity[item_idx, rated_items]"
        top_k_indices = np.argsort(sim_scores)[-5:]
        top_k_sim = sim_scores[top_k_indices]
        top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
        # Взвешенное среднее с учетом схожести
        if top_k_sim.sum() > 0:
"            pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
        else:
            pred_rating = 0.0
    
        return pred_rating
    
">   def evaluate(test_data: pd.DataFrame, model: ItemBasedCF) -> float:"
                                                 ^^^^^^^^^^^
E   NameError: name 'ItemBasedCF' is not defined
""
solutions\solution.py:102: NameError
________________________ test_evaluate_precision_at_2 _________________________
""
task_info = None
""
    def test_evaluate_precision_at_2(task_info):
">       if task_info[""metric""] != ""precision@2"":"
           ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object is not subscriptable
""
logic\tests\collaborative_tests.py:129: TypeError
_____________________ test_evaluate_returns_correct_rmse ______________________
""
task_info = None
""
    def test_evaluate_returns_correct_rmse(task_info):
">       if task_info[""metric""] != ""RMSE"":"
           ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object is not subscriptable
""
logic\tests\collaborative_tests.py:157: TypeError
__________________________ test_evaluate_recall_at_3 __________________________
""
task_info = None
""
    def test_evaluate_recall_at_3(task_info):
">       if task_info[""metric""] != ""recall@3"":"
           ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object is not subscriptable
""
logic\tests\collaborative_tests.py:178: TypeError
=========================== short test summary info ===========================
FAILED logic/tests/collaborative_tests.py::test_has_required_functions - Name...
FAILED logic/tests/collaborative_tests.py::test_fit_runs_without_error - Name...
FAILED logic/tests/collaborative_tests.py::test_fit_and_recommend_on_generated[1]
FAILED logic/tests/collaborative_tests.py::test_fit_and_recommend_on_generated[2]
FAILED logic/tests/collaborative_tests.py::test_fit_and_recommend_on_generated[3]
FAILED logic/tests/collaborative_tests.py::test_recommend_items_not_seen - Na...
FAILED logic/tests/collaborative_tests.py::test_repeat_fit_stability - NameEr...
FAILED logic/tests/collaborative_tests.py::test_evaluate_precision_at_2 - Typ...
FAILED logic/tests/collaborative_tests.py::test_evaluate_returns_correct_rmse
FAILED logic/tests/collaborative_tests.py::test_evaluate_recall_at_3 - TypeEr...
"======================== 10 failed, 1 passed in 1.16s ========================="
""
""
""
""
🎨 Стиль кода (flake8)
------------------------------
❌ flake8: Найдены проблемы со стилем:
"solution.py:10:1: E302 expected 2 blank lines, found 1"
solution.py:31:68: W291 trailing whitespace
solution.py:32:42: E128 continuation line under-indented for visual indent
solution.py:32:80: E501 line too long (82 > 79 characters)
solution.py:65:80: E501 line too long (80 > 79 characters)
"solution.py:103:1: E302 expected 2 blank lines, found 1"
"solution.py:121:1: E305 expected 2 blank lines after class or function definition, found 1"
solution.py:137:69: W292 no newline at end of file
""
""
🧱 Форматирование кода (black)
------------------------------
❌ black: Форматирование отличается от стандарта black.
Рекомендация: запустите команду `black solution.py` для автоформатирования.
