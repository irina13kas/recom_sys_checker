message
üß™ –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ç–µ—Å—Ç—ã
------------------------------
‚ùå –ù–µ–∫–æ—Ç–æ—Ä—ã–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ç–µ—Å—Ç—ã –Ω–µ –ø—Ä–æ–π–¥–µ–Ω—ã:
""
============================= test session starts =============================
"platform win32 -- Python 3.13.5, pytest-8.4.1, pluggy-1.6.0"
rootdir: C:\Users\mira1\OneDrive\–î–æ–∫—É–º–µ–Ω—Ç—ã\–ü–æ–ª–∏—Ç–µ—Ö\3 –∫—É—Ä—Å\6 —Å–µ–º–µ—Å—Ç—Ä\–ü—Ä–∞–∫—Ç–∏–∫–∞\recom_sys_checker
collected 11 items
""
logic\tests\collaborative_tests.py .FFFFFFFFFF
""
================================== FAILURES ===================================
_________________________ test_has_required_functions _________________________
""
    def test_has_required_functions():
>       solution = load_solution_module()
                   ^^^^^^^^^^^^^^^^^^^^^^
""
logic\tests\collaborative_tests.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
logic\tests\collaborative_tests.py:29: in load_solution_module
    spec.loader.exec_module(module)
<frozen importlib._bootstrap_external>:1026: in exec_module
    ???
<frozen importlib._bootstrap>:488: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
""
    import pandas as pd
    import numpy as np
    from scipy.sparse import csr_matrix
    from sklearn.metrics.pairwise import cosine_similarity
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import mean_squared_error
    from math import sqrt
    from typing import List
    
    
    item_similarity = None
    user_item_matrix = None
    items = None
    users = None
    
"    def fit(self, train_data: pd.DataFrame) -> None:"
"        """"""–û–±—É—á–∞–µ—Ç –º–æ–¥–µ–ª—å –Ω–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω–æ–º –¥–∞—Ç–∞—Å–µ—Ç–µ."""""""
        # –°–æ–∑–¥–∞–µ–º user-item –º–∞—Ç—Ä–∏—Ü—É
        self.users = train_data['user_id'].unique()
        self.items = train_data['item'].unique()
    
        # –°–æ–∑–¥–∞–µ–º —Ä–∞–∑—Ä–µ–∂–µ–Ω–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å-—Ñ–∏–ª—å–º
"        user_to_idx = {user: idx for idx, user in enumerate(self.users)}"
"        item_to_idx = {item: idx for idx, item in enumerate(self.items)}"
    
        rows = train_data['user_id'].map(user_to_idx)
        cols = train_data['item'].map(item_to_idx)
        ratings = train_data['rating']
    
"        self.user_item_matrix = csr_matrix((ratings, (rows, cols)),"
"                                            shape=(len(self.users), len(self.items)))"
    
        # –í—ã—á–∏—Å–ª—è–µ–º –∫–æ—Å–∏–Ω—É—Å–Ω—É—é —Å—Ö–æ–∂–µ—Å—Ç—å –º–µ–∂–¥—É —Ñ–∏–ª—å–º–∞–º–∏ (–∞–Ω–∞–ª–æ–≥ Pearson)
        self.item_similarity = cosine_similarity(self.user_item_matrix.T)
    
"    def recommend(self, user_id: int, k: int) -> List[int]:"
"        """"""–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∏–∑ k item_id, —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é."""""""
        if user_id not in self.users:
            return []
    
        user_idx = np.where(self.users == user_id)[0][0]
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
    
"        # –ò–Ω–¥–µ–∫—Å—ã —Ñ–∏–ª—å–º–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –µ—â–µ –Ω–µ –æ—Ü–µ–Ω–∏–ª"
        unrated_items = np.where(user_ratings == 0)[0]
    
        if len(unrated_items) == 0:
            return []
    
        # –ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–π—Ç–∏–Ω–≥–∏ –¥–ª—è –Ω–µ–æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö —Ñ–∏–ª—å–º–æ–≤
        pred_ratings = []
        for item_idx in unrated_items:
"            # –ù–∞—Ö–æ–¥–∏–º –∏–Ω–¥–µ–∫—Å—ã —Ñ–∏–ª—å–º–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ü–µ–Ω–∏–ª"
            rated_items = np.where(user_ratings > 0)[0]
    
            # –ë–µ—Ä–µ–º top-5 –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ—Ö–æ–∂–∏—Ö —Ñ–∏–ª—å–º–æ–≤ –∏–∑ –æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
"            sim_scores = self.item_similarity[item_idx, rated_items]"
            top_k_indices = np.argsort(sim_scores)[-5:]
            top_k_sim = sim_scores[top_k_indices]
            top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
            # –í–∑–≤–µ—à–µ–Ω–Ω–æ–µ —Å—Ä–µ–¥–Ω–µ–µ —Å —É—á–µ—Ç–æ–º —Å—Ö–æ–∂–µ—Å—Ç–∏
            if top_k_sim.sum() > 0:
"                pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
            else:
                pred_rating = 0
    
"            pred_ratings.append((self.items[item_idx], pred_rating))"
    
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω–æ–º—É —Ä–µ–π—Ç–∏–Ω–≥—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º top-k
"        pred_ratings.sort(key=lambda x: x[1], reverse=True)"
"        return [item for item, _ in pred_ratings[:k]]"
    
"    def predict(self, user_id: int, item_id: int) -> float:"
"        """"""–ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ—Ç —Ä–µ–π—Ç–∏–Ω–≥ –¥–ª—è –ø–∞—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å-—Ñ–∏–ª—å–º."""""""
        if user_id not in self.users or item_id not in self.items:
            return 0.0
    
        user_idx = np.where(self.users == user_id)[0][0]
        item_idx = np.where(self.items == item_id)[0][0]
    
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
        rated_items = np.where(user_ratings > 0)[0]
    
        if len(rated_items) == 0:
            return 0.0
    
        # –ë–µ—Ä–µ–º top-5 –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ—Ö–æ–∂–∏—Ö —Ñ–∏–ª—å–º–æ–≤ –∏–∑ –æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
"        sim_scores = self.item_similarity[item_idx, rated_items]"
        top_k_indices = np.argsort(sim_scores)[-5:]
        top_k_sim = sim_scores[top_k_indices]
        top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
        # –í–∑–≤–µ—à–µ–Ω–Ω–æ–µ —Å—Ä–µ–¥–Ω–µ–µ —Å —É—á–µ—Ç–æ–º —Å—Ö–æ–∂–µ—Å—Ç–∏
        if top_k_sim.sum() > 0:
"            pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
        else:
            pred_rating = 0.0
    
        return pred_rating
    
">   def evaluate(test_data: pd.DataFrame, model: ItemBasedCF) -> float:"
                                                 ^^^^^^^^^^^
E   NameError: name 'ItemBasedCF' is not defined
""
solutions\solution.py:102: NameError
_________________________ test_fit_runs_without_error _________________________
""
    def test_fit_runs_without_error():
        sample_data = get_dummy_data()
>       solution = load_solution_module()
                   ^^^^^^^^^^^^^^^^^^^^^^
""
logic\tests\collaborative_tests.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
logic\tests\collaborative_tests.py:29: in load_solution_module
    spec.loader.exec_module(module)
<frozen importlib._bootstrap_external>:1026: in exec_module
    ???
<frozen importlib._bootstrap>:488: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
""
    import pandas as pd
    import numpy as np
    from scipy.sparse import csr_matrix
    from sklearn.metrics.pairwise import cosine_similarity
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import mean_squared_error
    from math import sqrt
    from typing import List
    
    
    item_similarity = None
    user_item_matrix = None
    items = None
    users = None
    
"    def fit(self, train_data: pd.DataFrame) -> None:"
"        """"""–û–±—É—á–∞–µ—Ç –º–æ–¥–µ–ª—å –Ω–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω–æ–º –¥–∞—Ç–∞—Å–µ—Ç–µ."""""""
        # –°–æ–∑–¥–∞–µ–º user-item –º–∞—Ç—Ä–∏—Ü—É
        self.users = train_data['user_id'].unique()
        self.items = train_data['item'].unique()
    
        # –°–æ–∑–¥–∞–µ–º —Ä–∞–∑—Ä–µ–∂–µ–Ω–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å-—Ñ–∏–ª—å–º
"        user_to_idx = {user: idx for idx, user in enumerate(self.users)}"
"        item_to_idx = {item: idx for idx, item in enumerate(self.items)}"
    
        rows = train_data['user_id'].map(user_to_idx)
        cols = train_data['item'].map(item_to_idx)
        ratings = train_data['rating']
    
"        self.user_item_matrix = csr_matrix((ratings, (rows, cols)),"
"                                            shape=(len(self.users), len(self.items)))"
    
        # –í—ã—á–∏—Å–ª—è–µ–º –∫–æ—Å–∏–Ω—É—Å–Ω—É—é —Å—Ö–æ–∂–µ—Å—Ç—å –º–µ–∂–¥—É —Ñ–∏–ª—å–º–∞–º–∏ (–∞–Ω–∞–ª–æ–≥ Pearson)
        self.item_similarity = cosine_similarity(self.user_item_matrix.T)
    
"    def recommend(self, user_id: int, k: int) -> List[int]:"
"        """"""–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∏–∑ k item_id, —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é."""""""
        if user_id not in self.users:
            return []
    
        user_idx = np.where(self.users == user_id)[0][0]
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
    
"        # –ò–Ω–¥–µ–∫—Å—ã —Ñ–∏–ª—å–º–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –µ—â–µ –Ω–µ –æ—Ü–µ–Ω–∏–ª"
        unrated_items = np.where(user_ratings == 0)[0]
    
        if len(unrated_items) == 0:
            return []
    
        # –ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–π—Ç–∏–Ω–≥–∏ –¥–ª—è –Ω–µ–æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö —Ñ–∏–ª—å–º–æ–≤
        pred_ratings = []
        for item_idx in unrated_items:
"            # –ù–∞—Ö–æ–¥–∏–º –∏–Ω–¥–µ–∫—Å—ã —Ñ–∏–ª—å–º–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ü–µ–Ω–∏–ª"
            rated_items = np.where(user_ratings > 0)[0]
    
            # –ë–µ—Ä–µ–º top-5 –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ—Ö–æ–∂–∏—Ö —Ñ–∏–ª—å–º–æ–≤ –∏–∑ –æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
"            sim_scores = self.item_similarity[item_idx, rated_items]"
            top_k_indices = np.argsort(sim_scores)[-5:]
            top_k_sim = sim_scores[top_k_indices]
            top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
            # –í–∑–≤–µ—à–µ–Ω–Ω–æ–µ —Å—Ä–µ–¥–Ω–µ–µ —Å —É—á–µ—Ç–æ–º —Å—Ö–æ–∂–µ—Å—Ç–∏
            if top_k_sim.sum() > 0:
"                pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
            else:
                pred_rating = 0
    
"            pred_ratings.append((self.items[item_idx], pred_rating))"
    
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω–æ–º—É —Ä–µ–π—Ç–∏–Ω–≥—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º top-k
"        pred_ratings.sort(key=lambda x: x[1], reverse=True)"
"        return [item for item, _ in pred_ratings[:k]]"
    
"    def predict(self, user_id: int, item_id: int) -> float:"
"        """"""–ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ—Ç —Ä–µ–π—Ç–∏–Ω–≥ –¥–ª—è –ø–∞—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å-—Ñ–∏–ª—å–º."""""""
        if user_id not in self.users or item_id not in self.items:
            return 0.0
    
        user_idx = np.where(self.users == user_id)[0][0]
        item_idx = np.where(self.items == item_id)[0][0]
    
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
        rated_items = np.where(user_ratings > 0)[0]
    
        if len(rated_items) == 0:
            return 0.0
    
        # –ë–µ—Ä–µ–º top-5 –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ—Ö–æ–∂–∏—Ö —Ñ–∏–ª—å–º–æ–≤ –∏–∑ –æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
"        sim_scores = self.item_similarity[item_idx, rated_items]"
        top_k_indices = np.argsort(sim_scores)[-5:]
        top_k_sim = sim_scores[top_k_indices]
        top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
        # –í–∑–≤–µ—à–µ–Ω–Ω–æ–µ —Å—Ä–µ–¥–Ω–µ–µ —Å —É—á–µ—Ç–æ–º —Å—Ö–æ–∂–µ—Å—Ç–∏
        if top_k_sim.sum() > 0:
"            pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
        else:
            pred_rating = 0.0
    
        return pred_rating
    
">   def evaluate(test_data: pd.DataFrame, model: ItemBasedCF) -> float:"
                                                 ^^^^^^^^^^^
E   NameError: name 'ItemBasedCF' is not defined
""
solutions\solution.py:102: NameError
___________________ test_fit_and_recommend_on_generated[1] ____________________
""
"task_info = None, k = 1"
""
"    @pytest.mark.parametrize(""k"", [1, 2, 3])"
"    def test_fit_and_recommend_on_generated(task_info, k):"
>       solution = load_solution_module()
                   ^^^^^^^^^^^^^^^^^^^^^^
""
logic\tests\collaborative_tests.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
logic\tests\collaborative_tests.py:29: in load_solution_module
    spec.loader.exec_module(module)
<frozen importlib._bootstrap_external>:1026: in exec_module
    ???
<frozen importlib._bootstrap>:488: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
""
    import pandas as pd
    import numpy as np
    from scipy.sparse import csr_matrix
    from sklearn.metrics.pairwise import cosine_similarity
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import mean_squared_error
    from math import sqrt
    from typing import List
    
    
    item_similarity = None
    user_item_matrix = None
    items = None
    users = None
    
"    def fit(self, train_data: pd.DataFrame) -> None:"
"        """"""–û–±—É—á–∞–µ—Ç –º–æ–¥–µ–ª—å –Ω–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω–æ–º –¥–∞—Ç–∞—Å–µ—Ç–µ."""""""
        # –°–æ–∑–¥–∞–µ–º user-item –º–∞—Ç—Ä–∏—Ü—É
        self.users = train_data['user_id'].unique()
        self.items = train_data['item'].unique()
    
        # –°–æ–∑–¥–∞–µ–º —Ä–∞–∑—Ä–µ–∂–µ–Ω–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å-—Ñ–∏–ª—å–º
"        user_to_idx = {user: idx for idx, user in enumerate(self.users)}"
"        item_to_idx = {item: idx for idx, item in enumerate(self.items)}"
    
        rows = train_data['user_id'].map(user_to_idx)
        cols = train_data['item'].map(item_to_idx)
        ratings = train_data['rating']
    
"        self.user_item_matrix = csr_matrix((ratings, (rows, cols)),"
"                                            shape=(len(self.users), len(self.items)))"
    
        # –í—ã—á–∏—Å–ª—è–µ–º –∫–æ—Å–∏–Ω—É—Å–Ω—É—é —Å—Ö–æ–∂–µ—Å—Ç—å –º–µ–∂–¥—É —Ñ–∏–ª—å–º–∞–º–∏ (–∞–Ω–∞–ª–æ–≥ Pearson)
        self.item_similarity = cosine_similarity(self.user_item_matrix.T)
    
"    def recommend(self, user_id: int, k: int) -> List[int]:"
"        """"""–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∏–∑ k item_id, —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é."""""""
        if user_id not in self.users:
            return []
    
        user_idx = np.where(self.users == user_id)[0][0]
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
    
"        # –ò–Ω–¥–µ–∫—Å—ã —Ñ–∏–ª—å–º–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –µ—â–µ –Ω–µ –æ—Ü–µ–Ω–∏–ª"
        unrated_items = np.where(user_ratings == 0)[0]
    
        if len(unrated_items) == 0:
            return []
    
        # –ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–π—Ç–∏–Ω–≥–∏ –¥–ª—è –Ω–µ–æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö —Ñ–∏–ª—å–º–æ–≤
        pred_ratings = []
        for item_idx in unrated_items:
"            # –ù–∞—Ö–æ–¥–∏–º –∏–Ω–¥–µ–∫—Å—ã —Ñ–∏–ª—å–º–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ü–µ–Ω–∏–ª"
            rated_items = np.where(user_ratings > 0)[0]
    
            # –ë–µ—Ä–µ–º top-5 –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ—Ö–æ–∂–∏—Ö —Ñ–∏–ª—å–º–æ–≤ –∏–∑ –æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
"            sim_scores = self.item_similarity[item_idx, rated_items]"
            top_k_indices = np.argsort(sim_scores)[-5:]
            top_k_sim = sim_scores[top_k_indices]
            top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
            # –í–∑–≤–µ—à–µ–Ω–Ω–æ–µ —Å—Ä–µ–¥–Ω–µ–µ —Å —É—á–µ—Ç–æ–º —Å—Ö–æ–∂–µ—Å—Ç–∏
            if top_k_sim.sum() > 0:
"                pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
            else:
                pred_rating = 0
    
"            pred_ratings.append((self.items[item_idx], pred_rating))"
    
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω–æ–º—É —Ä–µ–π—Ç–∏–Ω–≥—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º top-k
"        pred_ratings.sort(key=lambda x: x[1], reverse=True)"
"        return [item for item, _ in pred_ratings[:k]]"
    
"    def predict(self, user_id: int, item_id: int) -> float:"
"        """"""–ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ—Ç —Ä–µ–π—Ç–∏–Ω–≥ –¥–ª—è –ø–∞—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å-—Ñ–∏–ª—å–º."""""""
        if user_id not in self.users or item_id not in self.items:
            return 0.0
    
        user_idx = np.where(self.users == user_id)[0][0]
        item_idx = np.where(self.items == item_id)[0][0]
    
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
        rated_items = np.where(user_ratings > 0)[0]
    
        if len(rated_items) == 0:
            return 0.0
    
        # –ë–µ—Ä–µ–º top-5 –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ—Ö–æ–∂–∏—Ö —Ñ–∏–ª—å–º–æ–≤ –∏–∑ –æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
"        sim_scores = self.item_similarity[item_idx, rated_items]"
        top_k_indices = np.argsort(sim_scores)[-5:]
        top_k_sim = sim_scores[top_k_indices]
        top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
        # –í–∑–≤–µ—à–µ–Ω–Ω–æ–µ —Å—Ä–µ–¥–Ω–µ–µ —Å —É—á–µ—Ç–æ–º —Å—Ö–æ–∂–µ—Å—Ç–∏
        if top_k_sim.sum() > 0:
"            pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
        else:
            pred_rating = 0.0
    
        return pred_rating
    
">   def evaluate(test_data: pd.DataFrame, model: ItemBasedCF) -> float:"
                                                 ^^^^^^^^^^^
E   NameError: name 'ItemBasedCF' is not defined
""
solutions\solution.py:102: NameError
___________________ test_fit_and_recommend_on_generated[2] ____________________
""
"task_info = None, k = 2"
""
"    @pytest.mark.parametrize(""k"", [1, 2, 3])"
"    def test_fit_and_recommend_on_generated(task_info, k):"
>       solution = load_solution_module()
                   ^^^^^^^^^^^^^^^^^^^^^^
""
logic\tests\collaborative_tests.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
logic\tests\collaborative_tests.py:29: in load_solution_module
    spec.loader.exec_module(module)
<frozen importlib._bootstrap_external>:1026: in exec_module
    ???
<frozen importlib._bootstrap>:488: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
""
    import pandas as pd
    import numpy as np
    from scipy.sparse import csr_matrix
    from sklearn.metrics.pairwise import cosine_similarity
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import mean_squared_error
    from math import sqrt
    from typing import List
    
    
    item_similarity = None
    user_item_matrix = None
    items = None
    users = None
    
"    def fit(self, train_data: pd.DataFrame) -> None:"
"        """"""–û–±—É—á–∞–µ—Ç –º–æ–¥–µ–ª—å –Ω–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω–æ–º –¥–∞—Ç–∞—Å–µ—Ç–µ."""""""
        # –°–æ–∑–¥–∞–µ–º user-item –º–∞—Ç—Ä–∏—Ü—É
        self.users = train_data['user_id'].unique()
        self.items = train_data['item'].unique()
    
        # –°–æ–∑–¥–∞–µ–º —Ä–∞–∑—Ä–µ–∂–µ–Ω–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å-—Ñ–∏–ª—å–º
"        user_to_idx = {user: idx for idx, user in enumerate(self.users)}"
"        item_to_idx = {item: idx for idx, item in enumerate(self.items)}"
    
        rows = train_data['user_id'].map(user_to_idx)
        cols = train_data['item'].map(item_to_idx)
        ratings = train_data['rating']
    
"        self.user_item_matrix = csr_matrix((ratings, (rows, cols)),"
"                                            shape=(len(self.users), len(self.items)))"
    
        # –í—ã—á–∏—Å–ª—è–µ–º –∫–æ—Å–∏–Ω—É—Å–Ω—É—é —Å—Ö–æ–∂–µ—Å—Ç—å –º–µ–∂–¥—É —Ñ–∏–ª—å–º–∞–º–∏ (–∞–Ω–∞–ª–æ–≥ Pearson)
        self.item_similarity = cosine_similarity(self.user_item_matrix.T)
    
"    def recommend(self, user_id: int, k: int) -> List[int]:"
"        """"""–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∏–∑ k item_id, —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é."""""""
        if user_id not in self.users:
            return []
    
        user_idx = np.where(self.users == user_id)[0][0]
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
    
"        # –ò–Ω–¥–µ–∫—Å—ã —Ñ–∏–ª—å–º–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –µ—â–µ –Ω–µ –æ—Ü–µ–Ω–∏–ª"
        unrated_items = np.where(user_ratings == 0)[0]
    
        if len(unrated_items) == 0:
            return []
    
        # –ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–π—Ç–∏–Ω–≥–∏ –¥–ª—è –Ω–µ–æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö —Ñ–∏–ª—å–º–æ–≤
        pred_ratings = []
        for item_idx in unrated_items:
"            # –ù–∞—Ö–æ–¥–∏–º –∏–Ω–¥–µ–∫—Å—ã —Ñ–∏–ª—å–º–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ü–µ–Ω–∏–ª"
            rated_items = np.where(user_ratings > 0)[0]
    
            # –ë–µ—Ä–µ–º top-5 –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ—Ö–æ–∂–∏—Ö —Ñ–∏–ª—å–º–æ–≤ –∏–∑ –æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
"            sim_scores = self.item_similarity[item_idx, rated_items]"
            top_k_indices = np.argsort(sim_scores)[-5:]
            top_k_sim = sim_scores[top_k_indices]
            top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
            # –í–∑–≤–µ—à–µ–Ω–Ω–æ–µ —Å—Ä–µ–¥–Ω–µ–µ —Å —É—á–µ—Ç–æ–º —Å—Ö–æ–∂–µ—Å—Ç–∏
            if top_k_sim.sum() > 0:
"                pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
            else:
                pred_rating = 0
    
"            pred_ratings.append((self.items[item_idx], pred_rating))"
    
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω–æ–º—É —Ä–µ–π—Ç–∏–Ω–≥—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º top-k
"        pred_ratings.sort(key=lambda x: x[1], reverse=True)"
"        return [item for item, _ in pred_ratings[:k]]"
    
"    def predict(self, user_id: int, item_id: int) -> float:"
"        """"""–ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ—Ç —Ä–µ–π—Ç–∏–Ω–≥ –¥–ª—è –ø–∞—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å-—Ñ–∏–ª—å–º."""""""
        if user_id not in self.users or item_id not in self.items:
            return 0.0
    
        user_idx = np.where(self.users == user_id)[0][0]
        item_idx = np.where(self.items == item_id)[0][0]
    
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
        rated_items = np.where(user_ratings > 0)[0]
    
        if len(rated_items) == 0:
            return 0.0
    
        # –ë–µ—Ä–µ–º top-5 –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ—Ö–æ–∂–∏—Ö —Ñ–∏–ª—å–º–æ–≤ –∏–∑ –æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
"        sim_scores = self.item_similarity[item_idx, rated_items]"
        top_k_indices = np.argsort(sim_scores)[-5:]
        top_k_sim = sim_scores[top_k_indices]
        top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
        # –í–∑–≤–µ—à–µ–Ω–Ω–æ–µ —Å—Ä–µ–¥–Ω–µ–µ —Å —É—á–µ—Ç–æ–º —Å—Ö–æ–∂–µ—Å—Ç–∏
        if top_k_sim.sum() > 0:
"            pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
        else:
            pred_rating = 0.0
    
        return pred_rating
    
">   def evaluate(test_data: pd.DataFrame, model: ItemBasedCF) -> float:"
                                                 ^^^^^^^^^^^
E   NameError: name 'ItemBasedCF' is not defined
""
solutions\solution.py:102: NameError
___________________ test_fit_and_recommend_on_generated[3] ____________________
""
"task_info = None, k = 3"
""
"    @pytest.mark.parametrize(""k"", [1, 2, 3])"
"    def test_fit_and_recommend_on_generated(task_info, k):"
>       solution = load_solution_module()
                   ^^^^^^^^^^^^^^^^^^^^^^
""
logic\tests\collaborative_tests.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
logic\tests\collaborative_tests.py:29: in load_solution_module
    spec.loader.exec_module(module)
<frozen importlib._bootstrap_external>:1026: in exec_module
    ???
<frozen importlib._bootstrap>:488: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
""
    import pandas as pd
    import numpy as np
    from scipy.sparse import csr_matrix
    from sklearn.metrics.pairwise import cosine_similarity
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import mean_squared_error
    from math import sqrt
    from typing import List
    
    
    item_similarity = None
    user_item_matrix = None
    items = None
    users = None
    
"    def fit(self, train_data: pd.DataFrame) -> None:"
"        """"""–û–±—É—á–∞–µ—Ç –º–æ–¥–µ–ª—å –Ω–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω–æ–º –¥–∞—Ç–∞—Å–µ—Ç–µ."""""""
        # –°–æ–∑–¥–∞–µ–º user-item –º–∞—Ç—Ä–∏—Ü—É
        self.users = train_data['user_id'].unique()
        self.items = train_data['item'].unique()
    
        # –°–æ–∑–¥–∞–µ–º —Ä–∞–∑—Ä–µ–∂–µ–Ω–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å-—Ñ–∏–ª—å–º
"        user_to_idx = {user: idx for idx, user in enumerate(self.users)}"
"        item_to_idx = {item: idx for idx, item in enumerate(self.items)}"
    
        rows = train_data['user_id'].map(user_to_idx)
        cols = train_data['item'].map(item_to_idx)
        ratings = train_data['rating']
    
"        self.user_item_matrix = csr_matrix((ratings, (rows, cols)),"
"                                            shape=(len(self.users), len(self.items)))"
    
        # –í—ã—á–∏—Å–ª—è–µ–º –∫–æ—Å–∏–Ω—É—Å–Ω—É—é —Å—Ö–æ–∂–µ—Å—Ç—å –º–µ–∂–¥—É —Ñ–∏–ª—å–º–∞–º–∏ (–∞–Ω–∞–ª–æ–≥ Pearson)
        self.item_similarity = cosine_similarity(self.user_item_matrix.T)
    
"    def recommend(self, user_id: int, k: int) -> List[int]:"
"        """"""–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∏–∑ k item_id, —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é."""""""
        if user_id not in self.users:
            return []
    
        user_idx = np.where(self.users == user_id)[0][0]
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
    
"        # –ò–Ω–¥–µ–∫—Å—ã —Ñ–∏–ª—å–º–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –µ—â–µ –Ω–µ –æ—Ü–µ–Ω–∏–ª"
        unrated_items = np.where(user_ratings == 0)[0]
    
        if len(unrated_items) == 0:
            return []
    
        # –ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–π—Ç–∏–Ω–≥–∏ –¥–ª—è –Ω–µ–æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö —Ñ–∏–ª—å–º–æ–≤
        pred_ratings = []
        for item_idx in unrated_items:
"            # –ù–∞—Ö–æ–¥–∏–º –∏–Ω–¥–µ–∫—Å—ã —Ñ–∏–ª—å–º–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ü–µ–Ω–∏–ª"
            rated_items = np.where(user_ratings > 0)[0]
    
            # –ë–µ—Ä–µ–º top-5 –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ—Ö–æ–∂–∏—Ö —Ñ–∏–ª—å–º–æ–≤ –∏–∑ –æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
"            sim_scores = self.item_similarity[item_idx, rated_items]"
            top_k_indices = np.argsort(sim_scores)[-5:]
            top_k_sim = sim_scores[top_k_indices]
            top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
            # –í–∑–≤–µ—à–µ–Ω–Ω–æ–µ —Å—Ä–µ–¥–Ω–µ–µ —Å —É—á–µ—Ç–æ–º —Å—Ö–æ–∂–µ—Å—Ç–∏
            if top_k_sim.sum() > 0:
"                pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
            else:
                pred_rating = 0
    
"            pred_ratings.append((self.items[item_idx], pred_rating))"
    
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω–æ–º—É —Ä–µ–π—Ç–∏–Ω–≥—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º top-k
"        pred_ratings.sort(key=lambda x: x[1], reverse=True)"
"        return [item for item, _ in pred_ratings[:k]]"
    
"    def predict(self, user_id: int, item_id: int) -> float:"
"        """"""–ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ—Ç —Ä–µ–π—Ç–∏–Ω–≥ –¥–ª—è –ø–∞—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å-—Ñ–∏–ª—å–º."""""""
        if user_id not in self.users or item_id not in self.items:
            return 0.0
    
        user_idx = np.where(self.users == user_id)[0][0]
        item_idx = np.where(self.items == item_id)[0][0]
    
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
        rated_items = np.where(user_ratings > 0)[0]
    
        if len(rated_items) == 0:
            return 0.0
    
        # –ë–µ—Ä–µ–º top-5 –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ—Ö–æ–∂–∏—Ö —Ñ–∏–ª—å–º–æ–≤ –∏–∑ –æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
"        sim_scores = self.item_similarity[item_idx, rated_items]"
        top_k_indices = np.argsort(sim_scores)[-5:]
        top_k_sim = sim_scores[top_k_indices]
        top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
        # –í–∑–≤–µ—à–µ–Ω–Ω–æ–µ —Å—Ä–µ–¥–Ω–µ–µ —Å —É—á–µ—Ç–æ–º —Å—Ö–æ–∂–µ—Å—Ç–∏
        if top_k_sim.sum() > 0:
"            pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
        else:
            pred_rating = 0.0
    
        return pred_rating
    
">   def evaluate(test_data: pd.DataFrame, model: ItemBasedCF) -> float:"
                                                 ^^^^^^^^^^^
E   NameError: name 'ItemBasedCF' is not defined
""
solutions\solution.py:102: NameError
________________________ test_recommend_items_not_seen ________________________
""
task_info = None
""
    def test_recommend_items_not_seen(task_info):
>       solution = load_solution_module()
                   ^^^^^^^^^^^^^^^^^^^^^^
""
logic\tests\collaborative_tests.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
logic\tests\collaborative_tests.py:29: in load_solution_module
    spec.loader.exec_module(module)
<frozen importlib._bootstrap_external>:1026: in exec_module
    ???
<frozen importlib._bootstrap>:488: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
""
    import pandas as pd
    import numpy as np
    from scipy.sparse import csr_matrix
    from sklearn.metrics.pairwise import cosine_similarity
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import mean_squared_error
    from math import sqrt
    from typing import List
    
    
    item_similarity = None
    user_item_matrix = None
    items = None
    users = None
    
"    def fit(self, train_data: pd.DataFrame) -> None:"
"        """"""–û–±—É—á–∞–µ—Ç –º–æ–¥–µ–ª—å –Ω–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω–æ–º –¥–∞—Ç–∞—Å–µ—Ç–µ."""""""
        # –°–æ–∑–¥–∞–µ–º user-item –º–∞—Ç—Ä–∏—Ü—É
        self.users = train_data['user_id'].unique()
        self.items = train_data['item'].unique()
    
        # –°–æ–∑–¥–∞–µ–º —Ä–∞–∑—Ä–µ–∂–µ–Ω–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å-—Ñ–∏–ª—å–º
"        user_to_idx = {user: idx for idx, user in enumerate(self.users)}"
"        item_to_idx = {item: idx for idx, item in enumerate(self.items)}"
    
        rows = train_data['user_id'].map(user_to_idx)
        cols = train_data['item'].map(item_to_idx)
        ratings = train_data['rating']
    
"        self.user_item_matrix = csr_matrix((ratings, (rows, cols)),"
"                                            shape=(len(self.users), len(self.items)))"
    
        # –í—ã—á–∏—Å–ª—è–µ–º –∫–æ—Å–∏–Ω—É—Å–Ω—É—é —Å—Ö–æ–∂–µ—Å—Ç—å –º–µ–∂–¥—É —Ñ–∏–ª—å–º–∞–º–∏ (–∞–Ω–∞–ª–æ–≥ Pearson)
        self.item_similarity = cosine_similarity(self.user_item_matrix.T)
    
"    def recommend(self, user_id: int, k: int) -> List[int]:"
"        """"""–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∏–∑ k item_id, —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é."""""""
        if user_id not in self.users:
            return []
    
        user_idx = np.where(self.users == user_id)[0][0]
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
    
"        # –ò–Ω–¥–µ–∫—Å—ã —Ñ–∏–ª—å–º–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –µ—â–µ –Ω–µ –æ—Ü–µ–Ω–∏–ª"
        unrated_items = np.where(user_ratings == 0)[0]
    
        if len(unrated_items) == 0:
            return []
    
        # –ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–π—Ç–∏–Ω–≥–∏ –¥–ª—è –Ω–µ–æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö —Ñ–∏–ª—å–º–æ–≤
        pred_ratings = []
        for item_idx in unrated_items:
"            # –ù–∞—Ö–æ–¥–∏–º –∏–Ω–¥–µ–∫—Å—ã —Ñ–∏–ª—å–º–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ü–µ–Ω–∏–ª"
            rated_items = np.where(user_ratings > 0)[0]
    
            # –ë–µ—Ä–µ–º top-5 –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ—Ö–æ–∂–∏—Ö —Ñ–∏–ª—å–º–æ–≤ –∏–∑ –æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
"            sim_scores = self.item_similarity[item_idx, rated_items]"
            top_k_indices = np.argsort(sim_scores)[-5:]
            top_k_sim = sim_scores[top_k_indices]
            top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
            # –í–∑–≤–µ—à–µ–Ω–Ω–æ–µ —Å—Ä–µ–¥–Ω–µ–µ —Å —É—á–µ—Ç–æ–º —Å—Ö–æ–∂–µ—Å—Ç–∏
            if top_k_sim.sum() > 0:
"                pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
            else:
                pred_rating = 0
    
"            pred_ratings.append((self.items[item_idx], pred_rating))"
    
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω–æ–º—É —Ä–µ–π—Ç–∏–Ω–≥—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º top-k
"        pred_ratings.sort(key=lambda x: x[1], reverse=True)"
"        return [item for item, _ in pred_ratings[:k]]"
    
"    def predict(self, user_id: int, item_id: int) -> float:"
"        """"""–ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ—Ç —Ä–µ–π—Ç–∏–Ω–≥ –¥–ª—è –ø–∞—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å-—Ñ–∏–ª—å–º."""""""
        if user_id not in self.users or item_id not in self.items:
            return 0.0
    
        user_idx = np.where(self.users == user_id)[0][0]
        item_idx = np.where(self.items == item_id)[0][0]
    
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
        rated_items = np.where(user_ratings > 0)[0]
    
        if len(rated_items) == 0:
            return 0.0
    
        # –ë–µ—Ä–µ–º top-5 –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ—Ö–æ–∂–∏—Ö —Ñ–∏–ª—å–º–æ–≤ –∏–∑ –æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
"        sim_scores = self.item_similarity[item_idx, rated_items]"
        top_k_indices = np.argsort(sim_scores)[-5:]
        top_k_sim = sim_scores[top_k_indices]
        top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
        # –í–∑–≤–µ—à–µ–Ω–Ω–æ–µ —Å—Ä–µ–¥–Ω–µ–µ —Å —É—á–µ—Ç–æ–º —Å—Ö–æ–∂–µ—Å—Ç–∏
        if top_k_sim.sum() > 0:
"            pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
        else:
            pred_rating = 0.0
    
        return pred_rating
    
">   def evaluate(test_data: pd.DataFrame, model: ItemBasedCF) -> float:"
                                                 ^^^^^^^^^^^
E   NameError: name 'ItemBasedCF' is not defined
""
solutions\solution.py:102: NameError
__________________________ test_repeat_fit_stability __________________________
""
task_info = None
""
    def test_repeat_fit_stability(task_info):
>       solution = load_solution_module()
                   ^^^^^^^^^^^^^^^^^^^^^^
""
logic\tests\collaborative_tests.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
logic\tests\collaborative_tests.py:29: in load_solution_module
    spec.loader.exec_module(module)
<frozen importlib._bootstrap_external>:1026: in exec_module
    ???
<frozen importlib._bootstrap>:488: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
""
    import pandas as pd
    import numpy as np
    from scipy.sparse import csr_matrix
    from sklearn.metrics.pairwise import cosine_similarity
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import mean_squared_error
    from math import sqrt
    from typing import List
    
    
    item_similarity = None
    user_item_matrix = None
    items = None
    users = None
    
"    def fit(self, train_data: pd.DataFrame) -> None:"
"        """"""–û–±—É—á–∞–µ—Ç –º–æ–¥–µ–ª—å –Ω–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω–æ–º –¥–∞—Ç–∞—Å–µ—Ç–µ."""""""
        # –°–æ–∑–¥–∞–µ–º user-item –º–∞—Ç—Ä–∏—Ü—É
        self.users = train_data['user_id'].unique()
        self.items = train_data['item'].unique()
    
        # –°–æ–∑–¥–∞–µ–º —Ä–∞–∑—Ä–µ–∂–µ–Ω–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å-—Ñ–∏–ª—å–º
"        user_to_idx = {user: idx for idx, user in enumerate(self.users)}"
"        item_to_idx = {item: idx for idx, item in enumerate(self.items)}"
    
        rows = train_data['user_id'].map(user_to_idx)
        cols = train_data['item'].map(item_to_idx)
        ratings = train_data['rating']
    
"        self.user_item_matrix = csr_matrix((ratings, (rows, cols)),"
"                                            shape=(len(self.users), len(self.items)))"
    
        # –í—ã—á–∏—Å–ª—è–µ–º –∫–æ—Å–∏–Ω—É—Å–Ω—É—é —Å—Ö–æ–∂–µ—Å—Ç—å –º–µ–∂–¥—É —Ñ–∏–ª—å–º–∞–º–∏ (–∞–Ω–∞–ª–æ–≥ Pearson)
        self.item_similarity = cosine_similarity(self.user_item_matrix.T)
    
"    def recommend(self, user_id: int, k: int) -> List[int]:"
"        """"""–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∏–∑ k item_id, —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é."""""""
        if user_id not in self.users:
            return []
    
        user_idx = np.where(self.users == user_id)[0][0]
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
    
"        # –ò–Ω–¥–µ–∫—Å—ã —Ñ–∏–ª—å–º–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –µ—â–µ –Ω–µ –æ—Ü–µ–Ω–∏–ª"
        unrated_items = np.where(user_ratings == 0)[0]
    
        if len(unrated_items) == 0:
            return []
    
        # –ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–π—Ç–∏–Ω–≥–∏ –¥–ª—è –Ω–µ–æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö —Ñ–∏–ª—å–º–æ–≤
        pred_ratings = []
        for item_idx in unrated_items:
"            # –ù–∞—Ö–æ–¥–∏–º –∏–Ω–¥–µ–∫—Å—ã —Ñ–∏–ª—å–º–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ü–µ–Ω–∏–ª"
            rated_items = np.where(user_ratings > 0)[0]
    
            # –ë–µ—Ä–µ–º top-5 –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ—Ö–æ–∂–∏—Ö —Ñ–∏–ª—å–º–æ–≤ –∏–∑ –æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
"            sim_scores = self.item_similarity[item_idx, rated_items]"
            top_k_indices = np.argsort(sim_scores)[-5:]
            top_k_sim = sim_scores[top_k_indices]
            top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
            # –í–∑–≤–µ—à–µ–Ω–Ω–æ–µ —Å—Ä–µ–¥–Ω–µ–µ —Å —É—á–µ—Ç–æ–º —Å—Ö–æ–∂–µ—Å—Ç–∏
            if top_k_sim.sum() > 0:
"                pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
            else:
                pred_rating = 0
    
"            pred_ratings.append((self.items[item_idx], pred_rating))"
    
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω–æ–º—É —Ä–µ–π—Ç–∏–Ω–≥—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º top-k
"        pred_ratings.sort(key=lambda x: x[1], reverse=True)"
"        return [item for item, _ in pred_ratings[:k]]"
    
"    def predict(self, user_id: int, item_id: int) -> float:"
"        """"""–ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ—Ç —Ä–µ–π—Ç–∏–Ω–≥ –¥–ª—è –ø–∞—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å-—Ñ–∏–ª—å–º."""""""
        if user_id not in self.users or item_id not in self.items:
            return 0.0
    
        user_idx = np.where(self.users == user_id)[0][0]
        item_idx = np.where(self.items == item_id)[0][0]
    
        user_ratings = self.user_item_matrix[user_idx].toarray().flatten()
        rated_items = np.where(user_ratings > 0)[0]
    
        if len(rated_items) == 0:
            return 0.0
    
        # –ë–µ—Ä–µ–º top-5 –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ—Ö–æ–∂–∏—Ö —Ñ–∏–ª—å–º–æ–≤ –∏–∑ –æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
"        sim_scores = self.item_similarity[item_idx, rated_items]"
        top_k_indices = np.argsort(sim_scores)[-5:]
        top_k_sim = sim_scores[top_k_indices]
        top_k_ratings = user_ratings[rated_items[top_k_indices]]
    
        # –í–∑–≤–µ—à–µ–Ω–Ω–æ–µ —Å—Ä–µ–¥–Ω–µ–µ —Å —É—á–µ—Ç–æ–º —Å—Ö–æ–∂–µ—Å—Ç–∏
        if top_k_sim.sum() > 0:
"            pred_rating = np.dot(top_k_sim, top_k_ratings) / top_k_sim.sum()"
        else:
            pred_rating = 0.0
    
        return pred_rating
    
">   def evaluate(test_data: pd.DataFrame, model: ItemBasedCF) -> float:"
                                                 ^^^^^^^^^^^
E   NameError: name 'ItemBasedCF' is not defined
""
solutions\solution.py:102: NameError
________________________ test_evaluate_precision_at_2 _________________________
""
task_info = None
""
    def test_evaluate_precision_at_2(task_info):
">       if task_info[""metric""] != ""precision@2"":"
           ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object is not subscriptable
""
logic\tests\collaborative_tests.py:129: TypeError
_____________________ test_evaluate_returns_correct_rmse ______________________
""
task_info = None
""
    def test_evaluate_returns_correct_rmse(task_info):
">       if task_info[""metric""] != ""RMSE"":"
           ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object is not subscriptable
""
logic\tests\collaborative_tests.py:157: TypeError
__________________________ test_evaluate_recall_at_3 __________________________
""
task_info = None
""
    def test_evaluate_recall_at_3(task_info):
">       if task_info[""metric""] != ""recall@3"":"
           ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object is not subscriptable
""
logic\tests\collaborative_tests.py:178: TypeError
=========================== short test summary info ===========================
FAILED logic/tests/collaborative_tests.py::test_has_required_functions - Name...
FAILED logic/tests/collaborative_tests.py::test_fit_runs_without_error - Name...
FAILED logic/tests/collaborative_tests.py::test_fit_and_recommend_on_generated[1]
FAILED logic/tests/collaborative_tests.py::test_fit_and_recommend_on_generated[2]
FAILED logic/tests/collaborative_tests.py::test_fit_and_recommend_on_generated[3]
FAILED logic/tests/collaborative_tests.py::test_recommend_items_not_seen - Na...
FAILED logic/tests/collaborative_tests.py::test_repeat_fit_stability - NameEr...
FAILED logic/tests/collaborative_tests.py::test_evaluate_precision_at_2 - Typ...
FAILED logic/tests/collaborative_tests.py::test_evaluate_returns_correct_rmse
FAILED logic/tests/collaborative_tests.py::test_evaluate_recall_at_3 - TypeEr...
"======================== 10 failed, 1 passed in 1.16s ========================="
""
""
""
""
üé® –°—Ç–∏–ª—å –∫–æ–¥–∞ (flake8)
------------------------------
‚ùå flake8: –ù–∞–π–¥–µ–Ω—ã –ø—Ä–æ–±–ª–µ–º—ã —Å–æ —Å—Ç–∏–ª–µ–º:
"solution.py:10:1: E302 expected 2 blank lines, found 1"
solution.py:31:68: W291 trailing whitespace
solution.py:32:42: E128 continuation line under-indented for visual indent
solution.py:32:80: E501 line too long (82 > 79 characters)
solution.py:65:80: E501 line too long (80 > 79 characters)
"solution.py:103:1: E302 expected 2 blank lines, found 1"
"solution.py:121:1: E305 expected 2 blank lines after class or function definition, found 1"
solution.py:137:69: W292 no newline at end of file
""
""
üß± –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞ (black)
------------------------------
‚ùå black: –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞ black.
–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: –∑–∞–ø—É—Å—Ç–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É `black solution.py` –¥–ª—è –∞–≤—Ç–æ—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.
